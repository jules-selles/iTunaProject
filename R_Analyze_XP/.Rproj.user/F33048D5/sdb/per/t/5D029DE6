{
    "contents" : "## function make session tablefrom OTree data\n\nmake.table.Otree <- function (xp.data, session, name, age, profession){\n  \n\n  xp = xp.data[which(xp.data$session_code==session),]\n  xp=xp[order(xp[,which(colnames(xp)=='subsession_round')],decreasing =F),]\n  \n  \n  \n  ## complete age / name and profession field \n  \n  # name\n  xp$player_name=as.factor(xp$player_name)\n  levels(xp$player_name)=c(levels(xp$player_name),name[1],name[2],name[3])\n  xp$player_name[which(xp$participant_id==\"P1\")] = name[1]\n  xp$player_name[which(xp$participant_id==\"P2\")] = name[2]\n  xp$player_name[which(xp$participant_id==\"P3\")] = name[3]\n  \n  # age \n  xp$player_age=as.factor(xp$player_age)\n  levels(xp$player_age)=c(levels(xp$player_age),age[1],age[2],age[3])\n  xp$player_age[which(xp$participant_id==\"P1\")] = age[1]\n  xp$player_age[which(xp$participant_id==\"P2\")] = age[2]\n  xp$player_age[which(xp$participant_id==\"P3\")] = age[3]\n  \n  \n  # profession\n  xp$player_profession=as.factor(xp$player_profession)\n  levels(xp$player_profession)=c(levels(xp$player_profession),profession[1],profession[2],profession[3])\n  xp$player_profession[which(xp$participant_id==\"P1\")] = profession[1]\n  xp$player_profession[which(xp$participant_id==\"P2\")] = profession[2]\n  xp$player_profession[which(xp$participant_id==\"P3\")] = profession[3]\n  \n  \n  # mean and sd : catch, catchpledge and profit \n  xp$group_meancatch=NULL\n  xp$group_meancatchpledge=NULL\n  xp$group_meanprofit=NULL\n  xp$group_sdcatch=NULL\n  xp$group_sdcatchpledge=NULL\n  xp$group_sdprofit=NULL\n  \n  for (j in 1: length(xp$player_profit)){\n    xp$group_meancatch[j] = mean(xp$player_catchchoice[which(xp$subsession_round==xp$subsession_round[j])],na.rm=TRUE)\n    xp$group_meancatchpledge[j] = mean(xp$player_catchpledge[which(xp$subsession_round==xp$subsession_round[j])],na.rm=TRUE)\n    xp$group_meanprofit[j] = mean(xp$player_profit[which(xp$subsession_round==xp$subsession_round[j])],na.rm=TRUE)\n    \n    xp$group_sdcatch[j] = sd(xp$player_catchchoice[which(xp$subsession_round==xp$subsession_round[j])],na.rm=TRUE)\n    xp$group_sdcatchpledge[j] = sd(xp$player_catchpledge[which(xp$subsession_round==xp$subsession_round[j])],na.rm=TRUE)\n    xp$group_sdprofit[j] = sd(xp$player_profit[which(xp$subsession_round==xp$subsession_round[j])],na.rm=TRUE)\n  }\n  \n  \n  # efficiency modulable by round in terme of profit subject t othe biomass level \n  \n  eff_mod <- function(obs.catch,obs.profit,biomass,optB,nbPlayers){\n    \n    eq.catch=matrix(data=NA,ncol=length(obs.catch),nrow=0)\n    eq.profit=matrix(data=NA,ncol=length(obs.catch),nrow=0)\n    \n    for (i in 1:length(obs.catch)){\n\n      if (is.na(biomass[i])){\n        eq.catch[i]   <- 0\n        eq.profit[i]  <- Profitplot(catch=eq.catch[i],biomass = biomass[i])\n      }else{\n      \n        if (biomass[i] == optB ){\n          eq.catch[i]   <- growth(biomass[i])\n          eq.profit[i]  <- Profitplot(catch=eq.catch[i],biomass = biomass[i])\n          \n        }else {\n          if (round((biomass[i] - optB)/nbPlayers)* nbPlayers >= 0){\n            eq.catch[i]   <- round((biomass[i] - optB)/nbPlayers)* nbPlayers\n            eq.profit[i]  <- Profitplot(catch=eq.catch[i],biomass = biomass[i])\n            \n          }else{\n            eq.catch[i]   <- 0\n            eq.profit[i]  <- Profitplot(catch=eq.catch[i],biomass = biomass[i])\n            \n          }  \n        }\n      }\n    }\n    \n    eff        <- (obs.profit/eq.profit)\n    eff.tot    <- sum(obs.profit,na.rm=TRUE)/sum(eq.profit,na.rm=TRUE)\n    \n    data=list(eff=eff,eff.tot=eff.tot)\n    \n    return(data)\n  }\n\n  xp$eff_mod_round = eff_mod(obs.catch=xp$group_totalcatch,obs.profit=xp$group_totalprofit,biomass=xp$group_biomasse,optB=optB,nbPlayers=nbPlayers)$eff\n  xp$eff_mod_total = eff_mod(obs.catch=xp$group_totalcatch,obs.profit=xp$group_totalprofit,biomass=xp$group_biomasse,optB=optB,nbPlayers=nbPlayers)$eff.tot\n  \n\n  # efficiency vs optimal path by round in term of profit subject to the biomass level \n  \n  eff_opt <- function(obs.profit){\n    \n    eq.profit =  c(rep(prof[1],3),rep(prof[2],length(obs.profit)-3))\n      \n    eff       <- (obs.profit/eq.profit)\n    eff.tot   <- sum(obs.profit,na.rm=TRUE)/sum(eq.profit,na.rm=TRUE)\n    \n    data=list(eff=eff,eff.tot=eff.tot)\n    \n    return(data)\n  }\n  \n  xp$eff_round = eff_opt(obs.profit=xp$group_totalprofit)$eff\n  xp$eff= eff_opt(obs.profit=xp$group_totalprofit)$eff.tot\n  \n  \n  \n  ##  deviation from optimum  ( profit deviation )\n  \n  path.prof.opt = c(rep(prof[1],3),rep(prof[2],length(xp$group_totalprofit)-3))\n  \n  xp$group_optProfDev = (xp$group_totalprofit - path.prof.opt)/ path.prof.opt\n  \n  ## efficiency ( profit efficiency )\n  \n  eq.profit =  c(rep(prof[1],3),rep(prof[2],length(xp$group_totalprofit)-3))\n  \n  xp$group_efficiency = (sum(xp$group_totalprofit,na.rm=T)/3)/ (sum(eq.profit,na.rm=T)/3)\n  \n  \n  ## Over - under exploitation (based on MSY)\n  \n  xp$group_stateExploitation = xp$group_totalcatch / Ymsy\n  \n  \n  ## prediction error & best response rate\n  \n  xp$player_predError = xp$player_otherchoice - (xp$group_totalcatch - xp$player_catchchoice) \n  \n # xp$player_bestRepDev   = \n  \n  for (j in 1: length(xp$player_profit)){\n    xp$player_meanpredError[j] = mean(xp$player_prederror[which(xp$subsession_round==xp$subsession_round[j])],na.rm=TRUE)\n    \n  }\n  \n  \n  return(xp)\n\n  \n}\n\n\n\n\n",
    "created" : 1481033240354.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "747344958",
    "id" : "5D029DE6",
    "lastKnownWriteTime" : 1481500090,
    "path" : "C:/Users/jselles/Dropbox/These/These_Ifremer/Documents_Travail/Modele_XP/XP_protocole/R_scripts/makeTable_Otree.R",
    "project_path" : "makeTable_Otree.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "type" : "r_source"
}